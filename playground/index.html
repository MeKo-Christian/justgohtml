<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>JustGoHTML Playground</title>
    <style>
      :root {
        --bg: #1a1a2e;
        --surface: #16213e;
        --surface-hover: #1f3056;
        --primary: #e94560;
        --secondary: #0f3460;
        --text: #eaeaea;
        --text-muted: #8892a0;
        --success: #4ade80;
        --error: #f87171;
        --border: #2a3a5a;
        --code-bg: #0d1321;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        height: 100vh;
        height: 100dvh;
        overflow: hidden;
      }

      body {
        font-family:
          -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.6;
        display: flex;
        flex-direction: column;
      }

      header {
        background: var(--surface);
        padding: 0 2rem;
        height: 60px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        flex-shrink: 0;
      }

      header h1 {
        font-size: 1.5rem;
        font-weight: 600;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      header h1 span {
        color: var(--primary);
      }

      .status {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
        color: var(--text-muted);
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-muted);
        transition: background 0.3s;
      }

      .status-dot.ready {
        background: var(--success);
      }

      .status-dot.error {
        background: var(--error);
      }

      .status-dot.loading {
        animation: pulse 1s infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.4;
        }
      }

      main {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto 1fr auto;
        gap: 1px;
        background: var(--border);
        flex: 1;
        min-height: 0;
      }

      .panel {
        background: var(--surface);
        display: grid;
        grid-template-rows: subgrid;
        grid-row: span 3;
        overflow: hidden;
      }

      .panel-header {
        padding: 0.75rem 1rem;
        background: var(--secondary);
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
        min-height: 3rem;
      }

      .panel-title {
        font-size: 0.875rem;
        font-weight: 500;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
      }

      .tabs {
        display: flex;
        gap: 0.25rem;
      }

      .tab {
        padding: 0.375rem 0.75rem;
        font-size: 0.75rem;
        background: transparent;
        border: 1px solid var(--border);
        border-radius: 4px;
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.2s;
      }

      .tab:hover {
        background: var(--surface-hover);
        color: var(--text);
      }

      .tab.active {
        background: var(--primary);
        border-color: var(--primary);
        color: white;
      }

      textarea {
        padding: 1rem;
        background: var(--code-bg);
        border: none;
        color: var(--text);
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.875rem;
        resize: none;
        outline: none;
        overflow: auto;
      }

      textarea::placeholder {
        color: var(--text-muted);
      }

      .content-area {
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      .output-container {
        flex: 1;
        overflow: auto;
        background: var(--code-bg);
      }

      .output {
        padding: 1rem;
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.875rem;
        white-space: pre-wrap;
        word-wrap: break-word;
      }

      .output.error {
        color: var(--error);
      }

      .controls {
        padding: 0.75rem 1rem;
        background: var(--secondary);
        border-top: 1px solid var(--border);
        display: flex;
        gap: 0.5rem;
        flex-wrap: wrap;
        align-items: center;
        min-height: 3rem;
      }

      .controls label {
        font-size: 0.75rem;
        color: var(--text-muted);
        display: flex;
        align-items: center;
        gap: 0.375rem;
      }

      .controls input[type="checkbox"] {
        accent-color: var(--primary);
      }

      .controls select {
        padding: 0.25rem 0.5rem;
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 4px;
        color: var(--text);
        font-size: 0.75rem;
        cursor: pointer;
      }

      button.action {
        padding: 0.5rem 1rem;
        background: var(--primary);
        border: none;
        border-radius: 4px;
        color: white;
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
      }

      button.action:hover:not(:disabled) {
        filter: brightness(1.1);
      }

      button.action:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      button.action.secondary {
        background: var(--surface);
        border: 1px solid var(--border);
      }

      .info {
        margin-left: auto;
        font-size: 0.75rem;
        color: var(--text-muted);
      }

      /* Tree view styles */
      .tree-node {
        margin-left: 1.25rem;
      }

      .tree-node:first-child {
        margin-left: 0;
      }

      .tree-tag {
        color: #7dd3fc;
      }

      .tree-attr-name {
        color: #fbbf24;
      }

      .tree-attr-value {
        color: #4ade80;
      }

      .tree-text {
        color: #d4d4d4;
      }

      .tree-comment {
        color: #6b7280;
        font-style: italic;
      }

      .tree-doctype {
        color: #c084fc;
      }

      /* HTML syntax highlighting */
      .html-tag {
        color: #7dd3fc;
      }

      .html-attr-name {
        color: #fbbf24;
      }

      .html-attr-value {
        color: #4ade80;
      }

      .html-comment {
        color: #6b7280;
        font-style: italic;
      }

      .html-doctype {
        color: #c084fc;
      }

      .html-text {
        color: #d4d4d4;
      }

      .html-entity {
        color: #f472b6;
      }

      /* Token view styles */
      .token {
        display: block;
        padding: 0.25rem 0;
        border-bottom: 1px solid var(--border);
      }

      .token-type {
        color: var(--primary);
        font-weight: 600;
      }

      .token-name {
        color: #7dd3fc;
      }

      .token-data {
        color: #d4d4d4;
      }

      /* Parse errors */
      .parse-errors {
        margin-top: 1rem;
        padding-top: 1rem;
        border-top: 1px solid var(--border);
      }

      .parse-errors h4 {
        color: var(--error);
        font-size: 0.75rem;
        margin-bottom: 0.5rem;
      }

      .parse-error {
        font-size: 0.75rem;
        color: var(--text-muted);
        padding: 0.25rem 0;
      }

      /* Query section styles */
      .query-section {
        padding: 0.75rem 1rem;
        background: var(--secondary);
        border-top: 1px solid var(--border);
        display: flex;
        gap: 0.5rem;
        align-items: center;
      }

      .query-section input[type="text"] {
        flex: 1;
        padding: 0.5rem 0.75rem;
        background: var(--code-bg);
        border: 1px solid var(--border);
        border-radius: 4px;
        color: var(--text);
        font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
        font-size: 0.875rem;
        outline: none;
      }

      .query-section input[type="text"]:focus {
        border-color: var(--primary);
      }

      .query-section input[type="text"]::placeholder {
        color: var(--text-muted);
      }

      .match-item {
        margin-bottom: 1rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border);
      }

      .match-item:last-child {
        border-bottom: none;
        margin-bottom: 0;
      }

      .match-header {
        font-size: 0.75rem;
        color: var(--primary);
        font-weight: 600;
        margin-bottom: 0.5rem;
      }

      .match-count {
        font-size: 0.875rem;
        color: var(--success);
        font-weight: 500;
      }

      .no-matches {
        color: var(--text-muted);
        font-style: italic;
      }

      @media (max-width: 768px) {
        main {
          display: flex;
          flex-direction: column;
        }

        .panel {
          display: flex;
          flex-direction: column;
          flex: 1;
          min-height: 0;
        }

        textarea,
        .content-area {
          flex: 1;
          min-height: 0;
        }
      }
    </style>
  </head>
  <body>
    <header>
      <h1><span>&lt;/&gt;</span> JustGoHTML Playground</h1>
      <div class="status">
        <div class="status-dot loading" id="status-dot"></div>
        <span id="status-text">Loading WASM...</span>
      </div>
    </header>

    <main>
      <div class="panel">
        <div class="panel-header">
          <span class="panel-title">HTML Input</span>
        </div>
        <textarea id="input" placeholder="Enter HTML to parse...">
<!DOCTYPE html>
<html>
<head>
    <title>Example</title>
</head>
<body>
    <h1>Hello World</h1>
    <p class="intro">This is a <strong>test</strong> document.</p>
    <ul>
        <li>Item 1</li>
        <li>Item 2</li>
    </ul>
    <!-- A comment -->
</body>
</html></textarea
        >
        <div class="controls">
          <button class="action" id="parse-btn" disabled>Parse</button>
          <label>
            <input type="checkbox" id="pretty" checked />
            Pretty print
          </label>
        </div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <span class="panel-title">Output</span>
          <div class="tabs">
            <button class="tab active" data-format="html">HTML</button>
            <button class="tab" data-format="text">Text</button>
            <button class="tab" data-format="markdown">Markdown</button>
            <button class="tab" data-format="tree">Tree</button>
            <button class="tab" data-format="tokens">Tokens</button>
            <button class="tab" data-format="query">Query</button>
          </div>
        </div>
        <div class="content-area">
          <div class="query-section" id="query-section" style="display: none">
            <input
              type="text"
              id="selector-input"
              placeholder="CSS selector (e.g., p.intro, ul > li, h1)"
            />
            <button class="action" id="query-btn">Query</button>
          </div>
          <div class="output-container">
            <div class="output" id="output">Output will appear here...</div>
          </div>
        </div>
        <div class="controls">
          <button class="action secondary" id="copy-btn" disabled>Copy</button>
          <span class="info" id="timing"></span>
        </div>
      </div>
    </main>

    <script src="wasm_exec.js"></script>
    <script>
      // State
      let wasmReady = false;
      let currentFormat = "html";
      let lastResult = null;

      // DOM elements
      const statusDot = document.getElementById("status-dot");
      const statusText = document.getElementById("status-text");
      const input = document.getElementById("input");
      const output = document.getElementById("output");
      const parseBtn = document.getElementById("parse-btn");
      const copyBtn = document.getElementById("copy-btn");
      const prettyCheckbox = document.getElementById("pretty");
      const timing = document.getElementById("timing");
      const tabs = document.querySelectorAll(".tab");
      const querySection = document.getElementById("query-section");
      const selectorInput = document.getElementById("selector-input");
      const queryBtn = document.getElementById("query-btn");

      // Initialize WASM
      async function initWasm() {
        try {
          const go = new Go();
          const result = await WebAssembly.instantiateStreaming(
            fetch("justgohtml.wasm"),
            go.importObject,
          );
          go.run(result.instance);

          // Wait a moment for the exports to be registered
          await new Promise((resolve) => setTimeout(resolve, 100));

          if (typeof JustGoHTML !== "undefined") {
            wasmReady = true;
            statusDot.classList.remove("loading");
            statusDot.classList.add("ready");
            statusText.textContent = `Ready (v${JustGoHTML.version})`;
            parseBtn.disabled = false;

            // Auto-parse on load
            parse();
          } else {
            throw new Error("JustGoHTML not initialized");
          }
        } catch (err) {
          statusDot.classList.remove("loading");
          statusDot.classList.add("error");
          statusText.textContent = "Failed to load";
          output.textContent = `Error loading WASM: ${err.message}`;
          output.classList.add("error");
          console.error("WASM init error:", err);
        }
      }

      // Parse HTML
      function parse() {
        if (!wasmReady) return;

        const html = input.value;
        const start = performance.now();

        try {
          if (currentFormat === "tokens") {
            lastResult = JustGoHTML.tokenize(html);
          } else if (currentFormat === "query") {
            runQuery();
            return;
          } else {
            lastResult = JustGoHTML.parse(html, {
              format: currentFormat,
              pretty: prettyCheckbox.checked,
            });
          }

          const elapsed = performance.now() - start;
          timing.textContent = `Parsed in ${elapsed.toFixed(2)}ms`;

          renderOutput();
          copyBtn.disabled = false;
          output.classList.remove("error");
        } catch (err) {
          output.textContent = `Error: ${err.message}`;
          output.classList.add("error");
          timing.textContent = "";
          copyBtn.disabled = true;
        }
      }

      // Run CSS selector query
      function runQuery() {
        if (!wasmReady) return;

        const html = input.value;
        const selector = selectorInput.value.trim();

        if (!selector) {
          output.innerHTML =
            '<span class="no-matches">Enter a CSS selector above to query the document</span>';
          timing.textContent = "";
          return;
        }

        const start = performance.now();

        try {
          lastResult = JustGoHTML.query(html, selector, {
            pretty: prettyCheckbox.checked,
          });

          const elapsed = performance.now() - start;

          if (!lastResult.success) {
            output.textContent = `Error: ${lastResult.error}`;
            output.classList.add("error");
            timing.textContent = "";
            return;
          }

          timing.textContent = `Query completed in ${elapsed.toFixed(2)}ms`;
          output.classList.remove("error");
          renderQueryResults();
          copyBtn.disabled = false;
        } catch (err) {
          output.textContent = `Error: ${err.message}`;
          output.classList.add("error");
          timing.textContent = "";
          copyBtn.disabled = true;
        }
      }

      // Render query results
      function renderQueryResults() {
        if (!lastResult || !lastResult.success) return;

        const { count, matches } = lastResult;

        if (count === 0) {
          output.innerHTML =
            '<span class="no-matches">No elements match the selector</span>';
          return;
        }

        let html = `<div class="match-count">${count} match${count === 1 ? "" : "es"} found</div>\n\n`;

        matches.forEach((match, i) => {
          html += `<div class="match-item">`;
          html += `<div class="match-header">Match ${i + 1}: &lt;${match.tagName}&gt;</div>`;
          html += `<pre>${escapeHtml(match.html)}</pre>`;
          html += `</div>`;
        });

        output.innerHTML = html;
      }

      // Render output based on format
      function renderOutput() {
        if (!lastResult) return;

        if (!lastResult.success) {
          output.textContent = `Error: ${lastResult.error}`;
          output.classList.add("error");
          return;
        }

        output.classList.remove("error");

        if (currentFormat === "tokens") {
          output.innerHTML = renderTokens(lastResult.tokens);
        } else if (currentFormat === "tree") {
          output.innerHTML = renderTree(lastResult.tree);
        } else if (currentFormat === "html") {
          output.innerHTML = highlightHtml(lastResult.result);
        } else {
          output.textContent = lastResult.result;
        }

        // Show parse errors if any
        if (lastResult.errors && lastResult.errors.length > 0) {
          const errorsHtml = `<div class="parse-errors">
                    <h4>Parse Errors (${lastResult.errors.length})</h4>
                    ${lastResult.errors
                      .map(
                        (e) =>
                          `<div class="parse-error">Line ${e.line}, Col ${e.column}: ${e.code}</div>`,
                      )
                      .join("")}
                </div>`;
          output.innerHTML += errorsHtml;
        }
      }

      // Render token stream
      function renderTokens(tokens) {
        if (!tokens) return "No tokens";
        return tokens
          .map((t) => {
            let content = `<span class="token-type">${t.type}</span>`;
            if (t.name)
              content += ` <span class="token-name">&lt;${t.name}&gt;</span>`;
            if (t.data !== undefined)
              content += ` <span class="token-data">"${escapeHtml(t.data)}"</span>`;
            if (t.attributes) {
              const attrs = Object.entries(t.attributes)
                .map(([k, v]) => `${k}="${escapeHtml(v)}"`)
                .join(" ");
              if (attrs)
                content += ` <span class="token-data">[${attrs}]</span>`;
            }
            return `<span class="token">${content}</span>`;
          })
          .join("");
      }

      // Render tree structure
      function renderTree(node, depth = 0) {
        if (!node) return "No tree";

        const indent = "  ".repeat(depth);
        let html = "";

        switch (node.type) {
          case "document":
            html = node.children.map((c) => renderTree(c, depth)).join("");
            break;
          case "doctype":
            html = `${indent}<span class="tree-doctype">&lt;!DOCTYPE ${node.name}&gt;</span>\n`;
            break;
          case "element":
            const attrs = Object.entries(node.attributes || {})
              .map(
                ([k, v]) =>
                  ` <span class="tree-attr-name">${k}</span>=<span class="tree-attr-value">"${escapeHtml(v)}"</span>`,
              )
              .join("");
            html = `${indent}<span class="tree-tag">&lt;${node.tagName}${attrs}&gt;</span>\n`;
            if (node.children) {
              html += node.children
                .map((c) => renderTree(c, depth + 1))
                .join("");
            }
            html += `${indent}<span class="tree-tag">&lt;/${node.tagName}&gt;</span>\n`;
            break;
          case "text":
            const text = node.data.trim();
            if (text) {
              html = `${indent}<span class="tree-text">#text: "${escapeHtml(text)}"</span>\n`;
            }
            break;
          case "comment":
            html = `${indent}<span class="tree-comment">&lt;!-- ${escapeHtml(node.data)} --&gt;</span>\n`;
            break;
        }

        return html;
      }

      // Escape HTML special characters
      function escapeHtml(str) {
        if (typeof str !== "string") return str;
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/\n/g, "\\n")
          .replace(/\r/g, "\\r")
          .replace(/\t/g, "\\t");
      }

      // Escape HTML for display (preserve whitespace)
      function escapeForDisplay(str) {
        if (typeof str !== "string") return str;
        return str
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;");
      }

      // Highlight HTML syntax
      function highlightHtml(html) {
        if (typeof html !== "string") return html;

        let result = "";
        let i = 0;

        while (i < html.length) {
          // Check for comments
          if (html.substring(i, i + 4) === "<!--") {
            const endIdx = html.indexOf("-->", i + 4);
            if (endIdx !== -1) {
              const comment = html.substring(i, endIdx + 3);
              result += `<span class="html-comment">${escapeForDisplay(comment)}</span>`;
              i = endIdx + 3;
              continue;
            }
          }

          // Check for DOCTYPE
          if (html.substring(i, i + 9).toLowerCase() === "<!doctype") {
            const endIdx = html.indexOf(">", i);
            if (endIdx !== -1) {
              const doctype = html.substring(i, endIdx + 1);
              result += `<span class="html-doctype">${escapeForDisplay(doctype)}</span>`;
              i = endIdx + 1;
              continue;
            }
          }

          // Check for tags
          if (html[i] === "<") {
            const endIdx = html.indexOf(">", i);
            if (endIdx !== -1) {
              const tag = html.substring(i, endIdx + 1);
              result += highlightTag(tag);
              i = endIdx + 1;
              continue;
            }
          }

          // Check for entities
          if (html[i] === "&") {
            const endIdx = html.indexOf(";", i);
            if (endIdx !== -1 && endIdx - i < 12) {
              const entity = html.substring(i, endIdx + 1);
              if (/^&[#\w]+;$/.test(entity)) {
                result += `<span class="html-entity">${escapeForDisplay(entity)}</span>`;
                i = endIdx + 1;
                continue;
              }
            }
          }

          // Regular text
          result += escapeForDisplay(html[i]);
          i++;
        }

        return result;
      }

      // Highlight a single HTML tag
      function highlightTag(tag) {
        // Simple closing tag
        if (/^<\/[\w-]+>$/.test(tag)) {
          return `<span class="html-tag">${escapeForDisplay(tag)}</span>`;
        }

        // Self-closing or opening tag with potential attributes
        let result = "";
        let inAttrValue = false;
        let attrValueQuote = "";
        let i = 0;

        // Opening bracket and tag name
        const tagNameMatch = tag.match(/^<\/?[\w-]+/);
        if (tagNameMatch) {
          result += `<span class="html-tag">${escapeForDisplay(tagNameMatch[0])}</span>`;
          i = tagNameMatch[0].length;
        }

        // Process attributes
        while (i < tag.length) {
          if (!inAttrValue) {
            // Look for attribute name
            const attrMatch = tag.substring(i).match(/^\s*([\w-]+)\s*=/);
            if (attrMatch) {
              const spaces = tag.substring(i).match(/^\s*/)[0];
              result += escapeForDisplay(spaces);
              result += `<span class="html-attr-name">${escapeForDisplay(attrMatch[1])}</span>=`;
              i += attrMatch[0].length;

              // Check for quoted value
              if (tag[i] === '"' || tag[i] === "'") {
                attrValueQuote = tag[i];
                inAttrValue = true;
                result += `<span class="html-attr-value">${attrValueQuote}`;
                i++;
              }
              continue;
            }

            // Closing bracket or other characters
            if (tag[i] === ">" || tag.substring(i, i + 2) === "/>") {
              result += `<span class="html-tag">${escapeForDisplay(tag.substring(i))}</span>`;
              break;
            }

            result += escapeForDisplay(tag[i]);
            i++;
          } else {
            // Inside attribute value
            if (tag[i] === attrValueQuote) {
              result += `${attrValueQuote}</span>`;
              inAttrValue = false;
              i++;
            } else {
              result += escapeForDisplay(tag[i]);
              i++;
            }
          }
        }

        return result;
      }

      // Copy output to clipboard
      async function copyToClipboard() {
        try {
          const text =
            currentFormat === "tokens" || currentFormat === "tree"
              ? output.innerText
              : output.textContent;
          await navigator.clipboard.writeText(text);
          const originalText = copyBtn.textContent;
          copyBtn.textContent = "Copied!";
          setTimeout(() => (copyBtn.textContent = originalText), 1500);
        } catch (err) {
          console.error("Copy failed:", err);
        }
      }

      // Event listeners
      parseBtn.addEventListener("click", parse);
      copyBtn.addEventListener("click", copyToClipboard);
      prettyCheckbox.addEventListener("change", parse);

      // Tab switching
      tabs.forEach((tab) => {
        tab.addEventListener("click", () => {
          tabs.forEach((t) => t.classList.remove("active"));
          tab.classList.add("active");
          currentFormat = tab.dataset.format;

          // Show/hide query section
          if (currentFormat === "query") {
            querySection.style.display = "flex";
          } else {
            querySection.style.display = "none";
          }

          parse();
        });
      });

      // Query button and input
      queryBtn.addEventListener("click", runQuery);
      selectorInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          runQuery();
        }
      });

      // Auto-parse on input (debounced)
      let parseTimeout;
      input.addEventListener("input", () => {
        clearTimeout(parseTimeout);
        parseTimeout = setTimeout(parse, 300);
      });

      // Initialize
      initWasm();
    </script>
  </body>
</html>
